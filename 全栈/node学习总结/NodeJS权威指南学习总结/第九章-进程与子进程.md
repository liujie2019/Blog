在NodeJS中，只支持单线程。但是在应用程序中，如果只使用单线程进行操作，从接收请求开始到返回响应为止的这一段时间里可能存在很长的一段等待时间。在这种场合下，如果能够使用多进程，**则可以为每个请求分配一个进程**，从而可以更好地使用服务器端的CPU资源。为了实现多进程处理，NodeJS中提供了**child_process模块和cluster模块**。

**child_process模块**用于实现在NodeJS应用程序中开启多个子进程并在各个子进程中运行各种不同的命令或执行NodeJS模块文件、可执行文件的处理。

**cluster模块**用于实现在NodeJS应用程序中开启多个子进程，在每个子进程中运行一个NodeJS应用程序副本的处理。

### 1. NodeJS中的进程(process对象)
在操作系统中，每个应用程序都是一个进程类的实例对象。

#### 1.1 进程对象的属性
* execPath：属性值为用来运行应用程序的可执行文件的绝对路径。
* version：属性值为NodeJS的版本号。
* versions：属性值为NodeJS及其各依赖的版本号。
* platform：属性值为当前运行NodeJS的平台。
* argv：属性值为运行NodeJS应用程序时的所有命令行参数。
* stdin：属性值为一个用于读入标准输入流的对象。
* stdout：属性值为一个用于写入标准输出流的对象。
* stderr：属性值为一个用于写入标准错误输出流的对象。
* pid：属性值为运行当前NodeJS应用程序的进程的PID。
* arch：属性值运行NodeJS应用程序的处理器架构。

```
console.log(process.execPath); // /usr/local/bin/node
```
```
// 默认情况下，标准输入流处于暂停状态，需要使用resume方法恢复读取标准输入流数据
process.stdin.resume();
process.stdin.on('data', (chunk) => {
    process.stdout.write('进程接收到数据：' + chunk);
});
# 测试结果：
123
进程接收到数据：123
234
进程接收到数据：234
```
```
process.argv.forEach((val, index, array) => {
    console.log(index + ':' + val);
});
# 测试结果：
0:/usr/local/bin/node
1:/Users/liujie/study/node/part9/demo2.js
2:one
3:two
4:three
```
#### 1.1 进程对象的方法与事件
* memoryUsage方法：获取运行NodeJS应用程序的进程的内存使用量。
* nextTick方法：用于将一个函数推迟到代码中所书写的下一个同步方法执行完毕时或异步方法的事件回调函数开始执行时调用。
* chdir方法：用于修改NodeJS应用程序中使用的当前工作目录。
* cwd方法：用于返回当前目录。
* exit方法：用于退出运行NodeJS应用程序的进程。
* kill方法：用于向一个进程发送信号。
* umask方法：用于读取或修改运行NodeJS应用程序的进程的文件权限掩码。子进程将继承父进程的文件权限掩码。
* uptime方法：返回NodeJS应用程序的当前运行时间
* hrtime方法：用于测试一个代码段的运行时间

```
console.log('当前目录：' + process.cwd());
process.chdir('../');
console.log('上层目录：' + process.cwd());
```
```
var oldmask, newmask = 0644;
oldmask = process.umask(newmask);
console.log('修改前的掩码：' + oldmask.toString(8) + '，修改后的掩码：' + newmask.toString(8));
```
```
const fs = require('fs');
const time = process.hrtime();
const data = fs.readFileSync('./demo.js');
const diff = process.hrtime(time);
// hrtime方法的返回值diff是一个数组
// 数组中包含两个时间，第一个时间单位为秒，第二个时间单位为纳秒
console.log(diff); // [ 0, 516897 ]
console.log('读文件操作耗费%d纳秒', diff[0] * 1e9 + diff[1]); // 读文件操作耗费516897纳秒
```

* exit事件：当运行的NodeJS应用程序的进程退出时触发进程对象的exit事件。

### 2. 创建多进程应用程序

#### 2.1 使用spawn方法开启子进程
在child_process模块中，spawn方法用于开启一个用于运行某个命令的子进程。**该方法返回一个隐式创建的代表子进程的ChildProcess对象。**

#### 2.2 使用fork方法开启子进程
在child_process模块中，fork方法用于开启一个专用于运行NodeJS中某个模块文件的子进程。**该方法返回一个隐式创建的代表子进程的ChildProcess对象。**

```
# demo.js
const cp = require('child_process');
const n = cp.fork(__dirname + '/test.js');
// 当父进程接收到子进程中发送的消息时，触发子进程对象的message事件
n.on('message', (msg) => {
    console.log('父进程接收到消息：', msg);
    process.exit();
});
// 在父进程中使用子进程对象的send方法向子进程发送消息
n.send({ usernName: '我是父进程' });
```
```
# test.js
// 当子进程对象接收到消息后，触发process对象的message事件
process.on('message', (msg) => {
    console.log('子进程接收到消息：', msg);
    // 在子进程中使用进程对象的send方法向父进程发送消息
    process.send({ name: '我是子进程' });
});
```
```
node demo.js
# 结果如下：
子进程接收到消息： { usernName: '我是父进程' }
父进程接收到消息： { name: '我是子进程' }
```
**需要注意：**

* 在使用fork方法时，当子进程中所有输入/输出操作执行完毕后，子进程不会自动退出。必须使用**process.exit()**方法将其显式退出。

#### 2.3 使用exec方法开启子进程
在child_process模块中，exec方法用于开启一个用于运行某个命令的子进程并缓存子进程中的输出结果。**该方法返回一个隐式创建的代表子进程的ChildProcess对象。**


#### 2.4 使用execFile方法开启子进程
在child_process模块中，execFile方法用于开启一个专用于运行某个可执行文件的子进程。**该方法返回一个隐式创建的代表子进程的ChildProcess对象。**

### 3. 在多个子进程中运行NodeJs应用程序

### 参考文档
1. [Node.js 中文网](http://nodejs.cn/api/process.html#process_signal_events)



